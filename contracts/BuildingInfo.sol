// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract BuildingInfo {
    struct Trait {
        uint256 id;
        uint256 range;
        uint256 value;
    }
    struct BuildingData {
        buildingType data;
        Trait[] traits;
        uint256 level;
        uint256 theme;
       
    }

    struct buildingType {
        string name; //eg house
        uint256[] inputResourceIds;
        uint256[] inputResourceAmounts;
        uint256[] outputResourceIds;
        uint256[] outputResourceAmounts;
        uint256 energyCost;
        bool exist;
    }

    mapping(uint256 => BuildingData) public buildingData;
    mapping(uint256 => buildingType) private types;
    address public shibavilleContract;
    uint256 counter = 0;

     modifier onlyShibavilleContract() {
        require(msg.sender == shibavilleContract, "Caller is not the Shibaville contract");
        _;
    }

    constructor() {
        shibavilleContract = msg.sender;
    }

    function setBuildingData(
        uint256 buildingId,
        uint256 buildingtype,
        uint256 theme
    ) external onlyShibavilleContract {
        require(types[buildingtype].exist, "This buildingtype dose not exist");
        buildingType memory data = types[buildingtype]; 
        buildingData[buildingId] = BuildingData({
            data: data,
            traits: setTraits(),
            level: 1,
            theme: theme
        });
    }

    function addNewType(string memory name,
         uint256[] memory inputResourceIds,
         uint256[] memory inputResourceAmounts,
         uint256[] memory outputResourceIds,
         uint256[] memory outputResourceAmounts,
         uint256 energyCost) external onlyShibavilleContract returns (uint256) {

        uint256 newId = counter + 1;
        types[newId] = buildingType({
            name: name,
            inputResourceIds: inputResourceIds,
            inputResourceAmounts: inputResourceAmounts,
            outputResourceIds: outputResourceIds,
            outputResourceAmounts: outputResourceAmounts,
            energyCost: energyCost,
            exist: true
        });

        counter++;
    return newId;
    }

    function getBuildingData(uint256 buildingId) external view returns (BuildingData memory) {
        return buildingData[buildingId];
    }

    function setTraits() internal pure returns (Trait[] memory) {
        // This traits should be generated by random number, now for the pupose of test we do this manually.      
        Trait[] memory traits = new Trait[](5);
        traits[0] = Trait(1, 0, 20);
        traits[1] = Trait(2, 3, 5);
        traits[2] = Trait(3, 5, 10);
        traits[3] = Trait(4, 1, 50);
        traits[4] = Trait(5, 3, 5);

        return traits;
    }

    // todo level update
}
